*Sample JSON*
{{{
{
  "name": "Onur YILDIZ", 
  "vip": true,
  "telephones": ["000000000", "111111111111"],
  "age": 24,
  "size": 1.72,
  "adresses": [
    {
      "adress": "blabla",
      "city": "Antalya",
      "pc": 7160
    },
    {
      "adress": "blabla",
      "city": "Adana",
      "pc": 1170
    }
  ]
}
}}}

*Delphi Code*
{{{
var
  X: ISuperObject;
begin
  X := TSuperObject.Create('{}');
  X.S['name'] := 'Onur YILDIZ';
  X.B['vip'] := true;
  with X.A['telephones'] do
  begin
   Add('000000000');
   Add('111111111111');
  end;
  X.I['age'] := 24;
  X.F['size'] := 1.72;
  with X.A['adresses'].O[0] {Auto Create} do
  begin
    S['adress'] := 'blabla';
    S['city'] := 'Antalya';
    I['pc'] := 7160;
  end;
  // or
  X.A['adresses'].O[1].S['adress'] := 'blabla';
  X.A['adresses'].O[1].S['city'] := 'Adana';
  X.A['adresses'].O[1].I['pc'] := 1170;
}}}

*Variant*
{{{
var 
  X: ISuperObject;
begin 
  X := TSuperObject.Creaet;
  X.V['A'] := 1;
  X.V['B'] := '2';
  X.V['C'] := 1.3;
  X.V['D'] := False;
  Memo1.Lines.Add(X.AsJSON);
end;
}}}
*Output*
{{{
{"A":1,"B":"2","D":false}
}}}


*Sample 2*
{{{
const
  JSN = '{ '+
        ' "adresses": [ '+
        '   { '+
        '     "adress": "blabla", '+
        '     "city": "Antalya", '+
        '     "pc": 7160 '+
        '   },'+
        '   { '+
        '     "adress": "blabla", '+
        '     "city": "Adana", '+
        '     "pc": 1170 '+
        '   } '+
        ' ] '+
        '}';
var
  X, Obj: ISuperObject;
  J: Integer;
begin
  X := TSuperObject.Create(JSN);
  with X.A['adresses'] do
    for J := 0 to Lenght -1 do
    begin
      Obj := O[J];
      Obj.First;
      while not Obj.EoF do
      begin
         Memo1.Lines.Add( Obj.CurrentKey + ' = ' + Obj.CurrentValue.Value );
         Obj.Next;
      end;
      Memo1.Lines.Add('------');
    end;
end;
}}}

*Output*
{{{
adress = blabla
city = Antalya
pc = 7160
------
adress = blabla
city = Adana
pc = 1170
}}}
------

*Marshalling*
{{{
type

  TTestSet = (ttA, ttB, ttC);

  TTestSets = set of TTestSet;
 
  TSubRec = record
    A: Integer;
    B: String; 
  end;

  TSubObj = class
    A: Integer;
    B: Integer; 
  end;  
  
  TTest = class / record
  private
    FB: String;
    FSubObj: TSubObj;
    FSubRec: TSubRec;
    FTestSets: TTestSets;
  public
    A: Integer;
    B: TTestSet;
    C: Boolean;
    property D: String read FB write FB;
    property E: TSubRec read FSubRec write FSubRec;
    property F: TSubObj read FSubObj write FSubObj;
    property G: TTestSets read FTestSets write FTestSets;
  end.
  
  implementation
  ...
  
  var Parse: TTest; // For Class;
      S: String;
  begin
    Parse := TTest.ToJSON('{"A": 1, "B": 0, "C": true, "D": "Hello", "E":{"A": 3, "B": "Delphi"}, "F": {"A": 4, "B": 5}, "G": [0,2]}');
  
    S := Parse.AsJSON;
  end;
  
  
  ...
  var Parse: TTest; // For Record;
      S: String;
  begin
    Parse := TSuperRecord<TTest>.ToJSON('{"A": 1, "B": 0, "C": true, "D": "Hello", "E":{"A": 3, "B": "Delphi"}, "F": {"A": 4, "B": 5}, "G": [0,2]}');
  
    S := TSuperRecord<TTest>(Parse).AsJSON;
  end;
  
  
  
}}}