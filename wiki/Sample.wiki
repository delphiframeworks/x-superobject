*Sample JSON*
{{{
{
  "name": "Onur YILDIZ", 
  "vip": true,
  "telephones": ["000000000", "111111111111"],
  "age": 24,
  "size": 1.72,
  "adresses": [
    {
      "adress": "blabla",
      "city": "Antalya",
      "pc": 7160
    },
    {
      "adress": "blabla",
      "city": "Adana",
      "pc": 1170
    }
  ]
}
}}}

*Delphi Code*
{{{
var
  X: ISuperObject;
begin
  X := TSuperObject.Create('{}');
  X.S['name'] := 'Onur YILDIZ';
  X.B['vip'] := true;
  with X.A['telephones'] do
  begin
   Add('000000000');
   Add('111111111111');
  end;
  X.I['age'] := 24;
  X.F['size'] := 1.72;
  with X.A['adresses'].O[0] {Auto Create} do
  begin
    S['adress'] := 'blabla';
    S['city'] := 'Antalya';
    I['pc'] := 7160;
  end;
  // or
  X.A['adresses'].O[1].S['adress'] := 'blabla';
  X.A['adresses'].O[1].S['city'] := 'Adana';
  X.A['adresses'].O[1].I['pc'] := 1170;
}}}


*Super Expression*
{{{
const
  JSON = '{ "o": { '+
         '    "1234567890": {'+
         '    "last use date": "2010-10-17T01:23:20",'+
         '    "create date": "2010-10-17T01:23:20",'+
         '    "name": "iPhone 8s"'+
         '	  }'+
         '  },'+
         '  "Index": 0, '+
         '  "Data": {"Index2": 1}, '+
         '  "a": [{'+
         '    "last use date": "2010-10-17T01:23:20",'+
         '    "create date": "2010-11-17T01:23:20",'+
         '    "name": "iPhone 8s",'+
         '    "arr": [1,2,3] '+
         '  }, '+
         '  {'+
         '    message: "hello"'+
         '  }]'+
         '}';

var
  X: ISuperObject;
  NewJSon: ISuperObject;
  NewArray: ISuperArray;
begin
  X := SO(JSON);
  ShowMessage( X['o."1234567890"."last use date"'].AsString );
  ShowMessage( X['a[Index]."create date"'].AsString );
  ShowMessage( X['a[Data.Index2].message'].AsString );
  X['a[0].arr'].AsArray.Add('test1');
  // -----
  NewJSON := X['{a: a[Index], b: a[Data.Index2].message, c: o."1234567890".name, d: 4, e: a[0].arr[2], f: " :) "}'].AsObject;
  NewArray := X['[a[Index], a[Data.Index2].message, Data.Index2, Index, 1, "1", "test"]'].AsArray;
end;
}}}


*Variant*
{{{
var 
  X: ISuperObject;
begin 
  X := TSuperObject.Create;
  X.V['A'] := 1;
  X.V['B'] := '2';
  X.V['C'] := 1.3;
  X.V['D'] := False;
  Memo1.Lines.Add(X.AsJSON);
end;
}}}
*Output*
{{{
{"A":1,"B":"2","C":1.3,"D":false}
}}}


*Sample 2*
{{{
const
  JSN = '{ '+
        ' "adresses": [ '+
        '   { '+
        '     "adress": "blabla", '+
        '     "city": "Antalya", '+
        '     "pc": 7160 '+
        '   },'+
        '   { '+
        '     "adress": "blabla", '+
        '     "city": "Adana", '+
        '     "pc": 1170 '+
        '   } '+
        ' ] '+
        '}';
var
  X, Obj: ISuperObject;
  J: Integer;
begin
  X := TSuperObject.Create(JSN);
  with X.A['adresses'] do
    for J := 0 to Lenght -1 do
    begin
      Obj := O[J];
      Obj.First;
      while not Obj.EoF do
      begin
         Memo1.Lines.Add( Obj.CurrentKey + ' = ' + Obj.CurrentValue.Value );
         Obj.Next;
      end;
      Memo1.Lines.Add('------');
    end;
end;
}}}

*OR (Enumerator)*

{{{
var
  X: ISuperObject;
  AMember,
  OMember: IMember;
begin
  X := TSuperObject.Create(JSN);

  for AMember in X.A['adresses'] do
      for OMember in AMember.AsObject do
          Memo1.Lines.Add(OMember.Name + ' = ' + OMember.ToString);

  Memo1.Lines.Add('------');
}}}

*Output*
{{{
adress = blabla
city = Antalya
pc = 7160
------
adress = blabla
city = Adana
pc = 1170
}}}
------

*Marshalling*
{{{
type

  TTestSet = (ttA, ttB, ttC);

  TTestSets = set of TTestSet;
 
  TSubRec = record
    A: Integer;
    B: String; 
  end;

  TSubObj = class
    A: Integer;
    B: Integer; 
  end;  
  
  TTest = class // Field, Property Support
  private
    FB: String;
    FSubObj: TSubObj;
    FSubRec: TSubRec;
    FTestSets: TTestSets;
  public
    A: Integer;
    B: TTestSet;
    C: Boolean;
    property D: String read FB write FB;
    property E: TSubRec read FSubRec write FSubRec;
    property F: TSubObj read FSubObj write FSubObj;
    property G: TTestSets read FTestSets write FTestSets;
  end;
  
  TTestRec = record // Only Field Support
    A: Integer;
    B: TTestSet;
    C: Boolean;
    D: String;
    E: TSubRec;
    F: TSubObj;
    G: TTestSets;
  end;
  
  implementation
  ...
  
  var 
    Parse: TTest; // For Class;
    S: String;
  begin
    Parse := TTest.FromJSON('{"A": 1, "B": 0, "C": true, "D": "Hello", "E":{"A": 3, "B": "Delphi"}, "F": {"A": 4, "B": 5}, "G": [0,2]}');
    S := Parse.AsJSON;
  end;
  
  
  ...
  var
    Parse: TTestRec; // For Record;
    S: String;
  begin
    Parse := TSuperRecord<TTestRec>.FromJSON('{"A": 1, "B": 0, "C": true, "D": "Hello", "E":{"A": 3, "B": "Delphi"}, "F": {"A": 4, "B": 5}, "G": [0,2]}');  
    S := TSuperRecord<TTestRec>.AsJSON(Parse);
  end;
  
  
  
}}}